---
layout: post
title:  "通信方法 Communication"
date:   2022-08-30 2:00:00 +0000
categories: jekyll update
---

# 通信方法

## 通信历史

信息从一个地方到另外一个地方的传递就是通信，信息是社会化需求的产物。可以说，一段信息产生出来的目的就是为了在某个特定的层面上进行传递和分享，传递信息的过程就是通信。

中国古代的通信方式多用于战时警告敌军进犯或传递情报，大家熟知的有连绵的烽火台、优雅的飞鸽传书、八百里加急的驿站体系等。南宋诗人马之纯曾写诗描绘烽火通信：“此到西陵路五千，烽台列置若星连。欲知万骑还千骑，只看三烟与两烟。不用赤囊来塞下，可须羽檄报军前。如何向日缘褒姒，无事蓬蓬火又燃。”就言简意赅的描述了烽火通信系统的组成结构，信号信息系统，远距离建立通信系统的优势，以及不遵守通信协议的通信双方会发生的通信故障。现代的通信方式更是多种多样，技术更新迅猛迭代，信息量和通信效率也大大提高，通信正在真真切切的改变我们的生活方式：邮递、电报（摩尔斯电码）、电话、传真、卫星通信、手机、数据通信、internet互联网、万维网，直到现在无处不在的万物互联。

通信的双方通常情况下是人，但也可以是机器设备或者应用程序。随着互联网行业的崛起，以服务为主的应用设计模式成为主导，通信的双方大多变成存在颗粒度更细微的服务，本章就是主要捋清楚服务通信的方法以及相关的重要知识点。

# 服务之间的通信

应用程序安装到操作系统中去之后，只是一堆静态的指令集。一些应用程序在操作系统中启动后就会持续在后台运行，以某种模式等待用户或者其他程序调用例如监听某个端口，这种应用程序的状态就是服务，服务是有生命周期的，在linux操作系统中可以通过类似`systemctl status sshd`的命令查看其服务状态。应用程序在操作系统启动到运行正常提供服务的过程中，是需要操作系统帮助调度系统硬件资源的例如CPU、内存等，而操作系统定义了可以进行资源申请、调度和独立运行的单位就是`进程`,可以理解为，进程是应用程序的运行过程，进程也有生命周期，通过命令`ps aux`查看其STAT列。一个应用程序的运行可以产生多个进程，一个进程的生命周期中也可以按照某种顺序执行多个应用程序。

### 进程、线程、协程

简单的理解，应用程序在操作系统中的运行过程就是进程形式。一个操作系统中的进程有先后时间关系，也有父子资源关系，每个进程在操作系统中都有唯一的识别号ID，被称之为`PID Process ID`, PID=0是系统内核加载完成，PID=1是操作系统启动完成可操作，其它应用程序的进程号一定是大于1的，所有（操作系统虚拟化技术的容器中,应用程序的进程号却是1，想一想为什么）。Linux操作系统下可以通过`pstree -pu | more`查看进程树。

提供网络服务的应用经常会用到父子进程的模式，父进程负责监听，等待有可能来自客户端的请求，当收到一个请求后，会使用fork()函数生成一个子进程（子进程返回0、父进程返回子进程的pid用于管理），然后由子进程专注负责处理该请求，父进程继续监听等待下一个请求。子进程会继承对应的父进程的大部分属性和资源(比如文件描述符，比如内存的堆和栈，为节省内存资源读时共享、写时复制)，根据具体需要，子进程可以运行和父进程一样的代码，也可以马上使用exec()调用来链式加载另一程序的代码做另外一个相关的事情，但pid不会改变。

Linux下的线程其实就是一个特殊的进程，更加轻量级：clone()函数生成一个线程，传递一个参数选择复制什么类型的数据（而不是像fork()一样全部复制），同一进程的所有线程会共享同一份内存和已打开的文件系统等资源，所以线程更小更加轻量，线程间共享内存的特点使得线程间通信协作的效率比进程间通信要提高不少，并且，线程是CPU运行调度的基本单元，可以充分利用现代计算机CPU多核多线程的特性。

fork(), exec()和clone()这些函数调用都是系统内核调用，占用资源不可控，该多少是多少。协程可以简单理解为工作在用户态的进一步轻量级的线程，支持协程的高阶语言例如Go/Python/C等，通过编码在一个线程运行的代码上自己又实现了一套更加灵活的代码段隔离、调度逻辑，减少了线程间切换的资源消耗和低效，可以随意自由切换不同的协程来回执行代码片段，虽然仍然是一个线程在运行，但因为切换上下文的效率的高效，使得多协程又进一步提升了并发效率，CPU计算的使用率也更上一个台阶，同时协程提供了更加友好易用的上层接口，所以用起来也更容易上手。

## 进程间通信IPC

一个计算机内，不同的表现为进程的应用之间也会有通信的需求，比如一个应用计算出的数据是另外一个应用的输入必要参数，或者一个应用是另一个应用的控制台等，同一台计算机内两个应用进程之间交换数据的过程就被称为进程间通信。进程间通信常用的方法有下面几种：

- 管道
    
    - 无名管道/管道

    Linux操作系统提供，父子进程间通信使用。一个管道会占用两个文件描述符，单向通信，如果需要双向通信，就需要两个管道资源。对一个管道，通信的一端关闭输出端，作为输入端，只写管道；另一端关闭输入端，作为输出端，只读管道，即实现了管道两段的通信。管道之间可以传输字节流，没有控制信号，因此通信效率比较低，需要约定字节流的固定长度或单独传输长度数据。
    
    - 有名管道/FIFO
    
    无名管道并没有文件名，因此只能使用父子进程的继承方式操作。有名管道有文件名，是一种特殊的文件类型，Linux中可以通过`mknod pipe1 p`创建一个pipe1的有名管道。有名管道有无名管道的所有功能和类似的逻辑，通信双方以只读/写模式打开文件读写某一个方向的管道，然后关闭管道，突破父子进程限制而实现任意两个进程之间通信。典型的应用例如管道符\|，比如两个命令之间传输数据`ls -al |wc -l`。

- 信号Singal
    
一个进程发给另一个进程，通知目标进程某个状态的改变或者异常发生等信号，主要用来控制管理进程，触发某个特殊动作等。典型的如kill命令 `kill -9 1234`，即kill进程向PID为1234的进程发送SIGKILL进程要求1234退出的通信过程。

- 信号量Semaphore

    信号量用于协调进程或线程间对共享资源的访问，本质上是一个通信双方进程都可以访问的全局变量。使用信号量的公共原则是：信号量值不能小于0； 访问资源时对信号量减一操作，访问完加一；当信号量为0时，必须等待。

    - 二进制信号量/互斥锁：初始值为1，只能有1和0两个值的信号量，和互斥锁的理念一致。比如多个用户在多个窗口卖票的场景。

    - 计数信号量：初始值可设置的大于1的信号量，用于限制访问同一同享资源的进程/线程个数。比如多个用户在多个窗口办理银行业务。

- 共享内存Share Memory

每个进程都会有自己的进程控制块和地址空间，且都有一个叫做页表的数据结构，存放进程的内存虚拟地址与真实的内存物理地址之间的映射关系。两个不同的虚拟逻辑地址通过页表映射到物理地址的同一个区域后，一个进程对该区域内数据的修改另一个进程会同步读到，这个就是共享内存的方法。共享内存的方式是没有同步机制的，因此通常配合信号量一起工作来实现同步和互斥机制，避免数据读写不一致的情况。

- 消息队列MQ

进程间通信消息量比较多、实时性不高的时候需要使用消息队列机制。除了无格式字节流，消息队列还可以传输更丰富类型的数据，并且也不会受缓冲区大小的限制。消息队列是有格式、有优先级的消息的链表形式，存放在操作系统的内存中，一个系统只有一个，由内核来维护，因此某个进程写入的消息要是始终没被读取/消费掉，即便该进程退出了，消息仍然还在。进程读取消息队列的消息不用遵循类似FIFO的原则，可以随机读取或者根据消息类型查询。

Linux系统中，上面的信号量、共享内存和消息队列都可以通过命令`ipcs -a`来查看。

- 本地Socket通信

Socket通信本是一种跨主机跨平台网络通信协议，本地socket通信借鉴了网络socket通信的工作模式，并在本机上进行了简化和优化：不走网络协议栈，不进行打包解包、校验、管理序列号等复杂操作，只是单纯的利用socket通信在进程之间复制数据包，效率很高。

## 网络通信协议

### TCP/UDP

TCP/UDP位于网络协议分层标准定义的第四层，基于下层IP网络层提供的服务，服务于上层应用，建立逻辑上的端到端的数据连接通道，负责该四层通道的寻址、连接的建立和释放、数据传输机制、流量控制、拥塞控制、多路复用、故障重传和恢复等。TCP面向连接，先发送三次握手控制信号建立通道，传输数据，传输完毕后发送四次挥手信号清理通道，整个过程严谨、可靠、刻板；UDP面向报文，不提前建立连接，直接发送带数据的报文然后结束，身形灵动、迅速、但也冒冒失失不可靠，基于UDP的可靠性措施例如前向纠错或者重传机制等都是有更上层协议来实现，比如VxLAN协议、HTTP3.0的QUIC协议。

TCP/UDP的共通处是用端口号标识端到端的连接，都有checksum来检验报文传输过程中是否数据被损坏修改，端口不可达时由协议栈生成ICMP错误信息报文返回。IP网络层的IP加上TCP/UDP传输层的端口是我们遇到的最为常见的表示网络上一个服务通信方式的方法。

#### TCP

- 序列号sequence number和确认号ackownledgement number

和三次握手四次挥手联系紧密的头字节内容有四个，分别是序列号SEQ Num和确认号ACK Num，以及标志现在什么阶段的同步SYN和确认ACK两个0/1的开关标志位flag。客户端和服务器端的首次TCP连接建立的三次握手过程中，其SYN信号里面的SEQ序列号分别由两者的操作系统通过特定算法产生，叫做初始序列号ISN，对端接收到后的ACK确认号为SEQ+1, 表达的意思是希望对方发送的下一个报文的序列号为这个号，然后相互确认知道数据发送完毕。

| 握手/挥手次数 | SEQ Num | ACK Num | flag SYN | flag ACK | flag FIN | flag PSH |
| --- | --- | --- | --- | --- | --- | --- |
| 第一次握手：客户端到服务端SYN信号 | 12345 | 0 | 1 | 0 | 0 | 0 |
| 第二次握手：服务端到客户端ACK+SYN信号 | 54321 | 12346 | 1 | 1 | 0 | 0 |
| 第三次握手：客户端到服务端ACK信号 | 12346 | 54322 | 0 | 1 | 0 | 0 |
| 连接建立，开始传输数据<br>客户端到服务端发送数据'hello!'(6个字符) | 12346 | 54322 | 0 | 1 | 0 | 1 |
| 服务端到客户端响应接收到了 | 54322 | 12352 | 0 | 1 | 0 | 0  |
| 第一次挥手：服务端到客户端ACK+FIN信号 | 54322 | 12352 | 0 | 1 | 1 | 0 |
| 第二次挥手：客户端到服务端ACK信号 | 12352 | 54323 | 0 | 1 | 0 | 0 |
| 第三次挥手：客户端到服务端ACK+FIN信号 | 12352 | 54323 | 0 | 1 | 1 | 0 |
| 第四次挥手：服务端到客户端ACK信号 | 54323 | 12353 | 0 | 1 | 0 | 0 |

- 窗口大小window

头字节里面还有一个重要的标志位是窗口大小window，不管是客户端还是服务端发送的报文里都有该字节，用来告诉通信的另外一方在连接阶段它自己一次能接收到的数据最大长度，超过该长度的数据必须要等待它发送ACK后再发送...对，就是缓冲区的概念。这种窗口机制的主要目的是通过流量控制来提高数据传输效率。

窗口的大小不是随机生成的，不同的操作系统对窗口大小的定义是不一样的。受限于tcp协议诞生时的低速网络视野，window字段只配置了两个字节，也就是最大值为65,536字节，后来又有协议补充了tcp option增加了缩放字段windows scale，才把窗口的最大值增加到65K字节的2^14倍，也就是1G多。很显然，窗口设置的越大，传输数据的效率越高（因为不用等待对方较多的ACK），但接收端内存消耗也越大，一个服务器对同一时间连接上来的每一个客户端都要准备一段内存作为窗口缓存区，乘起来的内存消耗也是相当大的。业内常用的TCP窗口设置为`带宽*RTT`,也就是`2*带宽*延迟`，可以在等ACK的时间内继续发送后一半数据，这样ACK到了，后一半数据也发完了，相把等待ACK回来的时间充分利用起来发送了数据，这样就提高的数据传输效率。

#### UDP

UDP头字节总长为8，包含源端口、目的端口、包长度和校验，后面就全部都是应用层交付下来的数据段了。UDP对数据段不拆分、不流控、完全保留原数据的边界，只是加上简单的UDP包头之后就尽最大努力发送出去，常见的UDP应用例如DNS协议。

UDP里面唯一的检测机制就是校验和，接收端接收到UDP报文后把报文头和内容进行校验和计算，跟报文中最后带的校验和进行匹配，不匹配就丢弃，也没有重传机制。

#### Socket

Socket套接字早于TCP/IP诞生，最初定义是用来描述命名空间内的任意元素的，一个套接字接口构成一个连接的一端，一个连接用一对套接字接口来描述，所以也可以使用套接字来描述网络连接，在这种场景下，socket可以理解为tcp/ip协议栈的具体接口实现和工具库，上层服务调用编程接口socket来实现网络进程之间的可控制的通信过程。

Linux操作系统下，万物都是文件，socket也是一种特殊的文件，socket编程的模式就是文件读写通用的“打开-读写-关闭”过程的方式，由c++实现，对外提供的主要函数接口API有：socket()创建一个描述符，相当于文件的代开，bind()是服务端绑定某特定ip和特定端口号对外提供服务，listen()服务端开始监听，connect()客户端向服务端发出连接请求，accept()服务端接受请求，表明连接建立了，可以开始网络I/O操作，read()读buffer中数据，write()写buffer中数据，close()完成数据通信后管理连接，相当于文件关闭。对应于tcp的三次握手和四次挥手过程，其实就是使用上述函数针对一个tcp连接两端的套接字接口元素进行操作的业务逻辑的实现和扩展。

### HTTP

Http是应用层的网络传输协议，基于tcp实现，也就是说，http的客户端和服务端建立连接的过程（大部分情况下）是使用socket编程逻辑来实现的。Http不是单纯的七层应用层协议，它其实包含了应用层、表示层（数据格式，编解码）、会话层（会话的建立中断）这上面三层的所有相关定义。

1989年，欧洲核子研究中心CERN的Tim Berners-Lee提出基于tcp/ip建设万维网www的构想，包含了三项关键技术：统一资源标识符uri，超文本标记语言html和用来传输html超文本文档的传输协议http，最早http传输协议只有get方法，即客户端从服务端get过来html文档。1996年，随着图片和音乐格式的信息出现，Http1.0发布，增加了head、post等方法和对应的状态码，引入header概念可以做更多的控制和扩展，也可以传输除了文本外的多媒体信息。伴随着http客户端-浏览器市场的发展和征战，1999年发布的http1.1正式确定了http协议的事实标准，互联网基于http1.1开始了统一和高速发展，http1.1增加了put、delete方法，开始支持缓存管理、长连接、大文件分块chunked等。2015年，基于google浏览器chrome使用的spyd协议，性能得到大大改善的http2.0诞生，Http2.0高度兼容http1.1，基于现代网络（宽带、移动网络、安全需求）特征增加了例如强制加密通信、二进制传输、头部数据压缩、多路复用（废弃http1.1的管道机制）、允许服务器向客户端推送等新功能，并基于HTTP2.0推出gRPC框架。2018年，还是基于google公司内部使用的建设于udp之上的quic协议（所以说http基于tcp实现不完全准确 :joy: ，需要限定版本来说明），http3.0开始标准化制定，为Web3.0体系和宏大的元宇宙提供传输协议支持。

从http协议的发展进程看，作为传输通信协议，Http1.0完全依赖于tcp，并且采用最简单的工作模式，一次tcp连接建立之后，客户端发送一次HTTP请求，服务端收到请求后返回响应结果结束，拆除tcp连接。http1.1因为添加了Header之后，可以做更多的传输控制，因此增加了管道机制，客户端在一次tcp连接的情况下，可以发送多个请求，服务器收到后依次响应返回，最后再拆除tcp连接；服务器响应这些请求中遵循按顺序排队处理原则，会有队头堵塞问题，因此http2.0采用多路复用机制，一次tcp内的多次请求和多次响应可以不受先后影响，有些情况下，甚至可以一个耗时久的请求处理过程中，可以先返回一部分响应，然后响应二个请求，接下来再响应第一个请求处理的后半部分。Http1.1传输大文件时会使用分块传输编码，头部信息标注为`Transfer-Encoding: chunked`，最后一个大小为0的块表示大文件传输完毕，而http2.0使用数据流ID标注标注每一次请求或响应需要传输的数据，不同数据流的帧可以乱序传输，同一数据流的帧接收完整后会被组装成消息然后进行处理。http2.0在tcp层面仍然有队头堵塞问题，无法处理tcp层的丢包问题，而http3.0基于udp建设，从根本上解决了对头阻塞，一个udp连接就是一个数据流，互不影响，而且得益于udp的轻量快捷性，一个http3.0通信/quic连接的建立只需要一个RT因此也更快，并支持连接迁移功能。

### Websocket

Http1.x对互联网的影响周期是至关重要的一段时间，在这段时间内，有些场景例如处理即时消息和其它实时通信需求像实时的音视频、在线教育、游戏、股票、社交订阅等，http1.x其实是天然的不擅长处理的，因为http1.x十分依赖于客户端主动向服务端发起请求，并且客户端在服务端响应请求的时候大多数时候都是静静等待着（半双工），所以这些实时通信场景http1.x是通过一系列的模拟方法例如轮询（ajax的XHR polling）、长轮询（长连接）来实现的，增加了服务器的负担，并且难免会收到中间网络设备缓存和延时增加的影响，包括后面基于http2.0增加的数据流和多路服务模式的服务端发送事件SSE，都不能完全撼动websocket的地位。2008年推出的websocket协议是和http在同一层的另一种应用层协议，同样基于tcp网络通信和socket编程接口，同样端口和http一样是80和443，甚至其连接建立的前半部分握手阶段都使用的是http协议（头字节标注是协议转换），这使得websocket对已有网络设施特别是防火墙的适应性毫无压力可言。通过http握手建立连接后，websocket协议便允许客户端和服务端在该tcp连接上进行双向全双工的通信，后续便和http协议没有关系了。客户端会每隔几分钟向服务端发送一个小控制帧ping，服务端收到后立即返回一个pong，用于维护客户端和服务端的socket连接可用状态。Websocket用于协议控制的数据包头部占比小效率高，再加上websocket是全双工通信模式，服务器可以随时给客户端发送信息，实时通信效率高时延小。

## 远程方法调用RPC

RPC不是一个具体协议或接口，而是一类远程过程调用技术的统称，具体实现RPC的方法有很多种，可以使用socket编程接口、http协议等。RPC的出现是伴随着分布式应用的发展而出现的，它模拟IPC的使用方法，只不过服务通信的主体双方处在不同的宿主机上，目标是像调用本地方法一样简单的调用远端服务。为了实现上面的目标，通常情况下，RPC框架都有自己的服务注册中心来管理服务的下线，管理连接池，监控服务的状态，配置容错机制等，这样服务调用方首先查询服务注册中心获取服务提供者的通信方式（通常都是 地址：端口 的方式），然后再发起请求建立连接，开始通信。相对于http调用的通用方式，RPC更加灵活可以自定义扩展性好、连接速度更快、通信效率更高、更安全，业内比较流行的RPC框架有谷歌的gRPC（基于http2.0）、阿里的dubbo等，各个有研发实力雄厚的大公司都会结合各自应用特点开发自己的RPC框架，实践后开源共享，小一点的公司要么使用开源RPC框架，要么使用http调用（Restful+JSON）来解决问题。有些宣称自己是微服务治理框架的核心其实就只是一个RPC框架，再在周边扩展一些必要的服务治理工具就组合成型。

除了理所应该添加的对服务调用的协调管理机制外，IPC中类似像一个方法调用另一个方法时传参结构化数据这样很简单的动作在RPC中变的复杂起来，调用方要先对结构化数据对象进行序列化，将对象的类型、对象的属性类型、对象的属性值等按照约定的编码规则写到二进制字节流中；服务方接收后，进行解码和反序列化，将二进制字节流转化为一个完整的对象，带入服务程序进行计算并返回结果，返回结构化数据结果的过程仍然是序列化和反序列化的过程。常用的用来传输数据对象的序列化协议有：XML，JSON，Hessian，Protobuf，Avro等等有很多，它们的区别在于通用性程度比如是不是各种数据对象都能序列化，兼容性比如版本升级后对原来版本的支持力度，跨平台跨语言性比如服务调用的两端程序的运行操作系统和开发语言不一样可不可以，安全性比如序列化过程中有没有加密机制和敏感信息处理机制，性能，序列化协议后的空间开销（越小网络传输越快）等。以gRPC为例，其传输协议是http2.0，序列化协议是Protobuf。
### 序列化

序列化的作用：

- 1：数据结构或对象的持久化存储：数据结构或数据对象是随着程序的运行而被创建，然后被程序回收，如果我们想永久地把对象的内容保存起来，则需要把它转化为字节序列保存在存储介质上，例如文件、缓存、或经由网络传输，此时就需要序列化。例如需要保存到磁盘的java对象必须是可序列化的，因此程序创建的每个JavaBean类都要实现序列化Serializeable接口。
- 2：网络传输对象：因为网络传输的数据必须是二进制数据的这个特点，所有可在网络上传输的对象都必须是可序列化的，比如Java的官方RPC实现RMI（remote method invoke, 即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会报错。
- 3：进程间传递对象：例如Android应用是基于Linux系统，不同进程之间的java对象是无法传输，但对对象进行序列化后，就可以在应用程序进程和服务端对象ActivityManagerService的进程之间传输。

## HTTP调用

相对于RPC调用这一层概念，如果应用端通过http标准协议去调用服务端的工作方式就是http调用。Http调用有自身的优势，它相对简单，天然跨各种平台和语言，穿透性好。

### HTTP调用和RPC调用区别

RPC是一个完整的远程调用方案，它包括了：接口规范+序列化反序列化规范+通信协议等。而http严格意义上讲只是一个通信协议，如果要与RPC放在一个层面进行比较，也应该是：Restful规范+序列化反序列化规范+http。

|调用|http+restful远程调用|RPC调用|
|---|---|---|
|可读性|&#x1F44D;可读性好|可读性似乎没有必要，因为可以引入网关增加可读性，并且远程调用大多都是内部应用之间的调用，框架认识可以解读就行
|通用性|&#x1F44D;穿透性强，网络防火墙支持、跨语言支持|通信协议的实现可以是四层/七层，可以是标准协议或非标准协议，因此穿透性不强
|效率|业务信息占比少，HTTP头部包含大量非业务信息，因此效率不高|&#x1F44D;可以使用非标tcp协议最大限度的提高通信传输效率
|易用性|调用远程方法麻烦，需要封装各种参数名和参数值|&#x1F44D;同一框架下，极大的提高了易用性
